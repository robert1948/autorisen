name: CI - Health Service

on:
  push:
    branches: [main, modularization/rfc]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test-health:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Check DockerHub secrets
        id: dockerhub-check
        run: |
          if [[ -z "${{ secrets.DOCKERHUB_USERNAME }}" || -z "${{ secrets.DOCKERHUB_TOKEN }}" ]]; then
            echo "dockerhub_ok=false" >> "$GITHUB_OUTPUT"
          else
            echo "dockerhub_ok=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Login to DockerHub (optional)
        if: steps.dockerhub-check.outputs.dockerhub_ok == 'true'
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: NOTE about DockerHub token
        if: steps.dockerhub-check.outputs.dockerhub_ok != 'true'
        run: |
          echo "DOCKERHUB_USERNAME or DOCKERHUB_TOKEN not set — skipping Docker login (this is ok for tests)."
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
      - name: Install deps
        run: |
          python -m pip install --upgrade pip virtualenv
          echo "Listing workspace files for debugging..."
          ls -R . | sed -n '1,200p'
          # Create a local venv at .venv so the workspace is self-contained
          python -m virtualenv .venv
          # Activate the venv for subsequent commands in this step
          . .venv/bin/activate
          if [ -f services/health/requirements.txt ]; then
            echo "Found services/health/requirements.txt — installing into .venv"
            pip install -r services/health/requirements.txt
          else
            echo "services/health/requirements.txt not found — falling back to explicit installs into .venv"
            pip install fastapi==0.95.2 uvicorn[standard]==0.22.0 pytest redis>=4.6.0,<5.0
          fi
      - name: Run tests
        id: pytest
        run: |
          mkdir -p tests-output
          # Activate the .venv created during the install step. If it doesn't exist, fall back to system python.
          if [ -f .venv/bin/activate ]; then
            . .venv/bin/activate
          fi
          # run pytest and capture full output to a file so we can upload it as an artifact
          set +o pipefail
          pytest services/health/tests -q 2>&1 | tee tests-output/pytest.txt
          RC=${PIPESTATUS[0]}
          set -o pipefail
          # Pytest returns 5 when no tests were collected; treat that as success for this CI job
          if [ "$RC" -eq 5 ]; then
            echo "No tests collected (pytest exit code 5) — treating as success"
            RC=0
          fi
          echo "PYTEST_EXIT=$RC" > tests-output/exitcode.txt
          if [ $RC -ne 0 ]; then
            echo "Pytest failed with exit code $RC" >&2
            exit $RC
          fi

      - name: Build and smoke-test Docker image
        id: smoke
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p tests-output
          # Skip if there's no services/health directory (keeps CI robust for branches without the PoC)
          if [ ! -d services/health ]; then
            echo "No services/health directory found — skipping image smoke-test."
            exit 0
          fi
          IMAGE_NAME="autolocal-health:ci"
          echo "Building Docker image $IMAGE_NAME"
          docker build -t "$IMAGE_NAME" services/health
          # Try to run container mapping host port 8000 first (simpler).
          # If port 8000 is in use, fall back to `-P` which publishes exposed ports to random host ports.
          CONTAINER_ID=""
          set +e
          CONTAINER_ID=$(docker run -d -p 8000:8000 "$IMAGE_NAME" 2>/dev/null)
          RC=$?
          set -e
          if [ $RC -eq 0 ] && [ -n "$CONTAINER_ID" ]; then
            echo "Started container $CONTAINER_ID with host port 8000"
            HOST_PORT=8000
          else
            echo "Port 8000 not available on runner, falling back to -P (publish exposed ports)"
            CONTAINER_ID=$(docker run -d -P "$IMAGE_NAME")
            echo "Started container $CONTAINER_ID"
            # Ensure we always try to clean up the container on exit
            trap 'docker rm -f "$CONTAINER_ID" >/dev/null 2>&1 || true' EXIT
            # Wait up to 30s for docker to report the mapped host port
            HOST_PORT=""
            for i in $(seq 1 30); do
              HOST_PORT=$(docker port "$CONTAINER_ID" 8000/tcp | sed -n 's/.*://p' || true)
              if [ -n "$HOST_PORT" ]; then
                break
              fi
              sleep 1
            done
          fi
          # Ensure we remove the container on successful exit too
          trap 'docker rm -f "$CONTAINER_ID" >/dev/null 2>&1 || true' EXIT
          if [ -z "$HOST_PORT" ]; then
            echo "Could not determine mapped host port" >&2
            docker logs "$CONTAINER_ID" || true
            docker rm -f "$CONTAINER_ID" || true
            exit 1
          fi
          echo "Mapped host port: $HOST_PORT"
          # Poll the host-mapped endpoint until it responds, up to 30s
          SUCCESS=1
          for i in $(seq 1 30); do
            if curl -sS --fail "http://127.0.0.1:$HOST_PORT/alive" >/dev/null 2>&1; then
              SUCCESS=0
              break
            fi
            sleep 1
          done
          if [ $SUCCESS -ne 0 ]; then
            echo "Smoke test failed - dumping container logs" >&2
            docker logs "$CONTAINER_ID" > ./tests-output/container.log || true
            docker rm -f "$CONTAINER_ID" || true
            exit 1
          fi
          echo "Smoke test passed"
          docker logs "$CONTAINER_ID" > ./tests-output/container.log || true
          docker rm -f "$CONTAINER_ID"

      - name: Upload test and container logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-ci-logs
          path: tests-output
